---
description: 
globs: 
alwaysApply: true
---
---
description: How we should prefer to code
globs: **/*

---
# Coding Pattern Preferences

## General Coding Principles
- If the user gives a precise request (ie: change the height of the container to 42px), always use that measurement itself. Never substitute a different measurement systems (for example, an equation). If an equation or other method is the right way in your opinion, stop and ask the user if they'd prefer this method.

- Always prefer simple solutions

- When operating in AGENT mode, always check the project TREE found in CURSOR_README.txt to make sure you have seen 1. any relevant pages are active and 2. what they do.

- Keep the codebase very clean and organized. Never add new files without expressed permission from the user

- You are careful to only make changes that are requested or you are confident are well-understood and related to the change being requested

- When fixing an issue or bug, do not introduce any new pattern or technology without first exhausting all options for the existing implementation. And if you finally do this, make sure to remove the old implementation afterwards so we don't duplicate logic

- Avoid writing scripts in files if possible, especially if the script is likely to be run only once

- Avoid having files over 200-300 lines long. Suggest refactoring at that point. 


## Documentation
- Always annotate the beginning of any code file with a brief plain-language statement of the file's responsibilities, followed by a list of the things the page accomplishes in the order they appear in the file

- When refactoring or changing a file's purpose, always update its header comment to reflect new responsibilities

- Add JSDoc comments for function parameters and return values to improve code readability and maintainability

- Maintain a document called "CURSOR_README.txt" that includes an updated TREE of the project, as well as a unified statement of all changes made to the project, including agenda items and goals

## Architecture Patterns
- Always use the state API functions (getSelectedDice(), addDie(), etc.) instead of directly manipulating the state object
- All state modifications should go through the appropriate state API methods
- Maintain clear separation between business logic, UI updates, animations, and event handling
- Ensure each file has a single responsibility and communicates with other modules through well-defined interfaces

## Implementation Standards
- Core functions should return consistent object structures to simplify integration
- For example, all roll functions should return {results, diceToAnimate, total} objects
- Add proper validation and error handling for user inputs
- Provide meaningful error messages and fallbacks for edge cases

## Testing and Quality
- Add console.log statements in key functions during development
- Include test functions for key features (like the percentile dice tests)
- Document test cases for each major feature
- Verify previous functionality still works after refactoring

## Component Compliance
- Ensure implementations adhere to the specific component rule sheets we've created
- Check relevant rule sheets before making significant changes to components
- When refactoring, update all dependent files in the same change
- Update documentation with refactoring rationale